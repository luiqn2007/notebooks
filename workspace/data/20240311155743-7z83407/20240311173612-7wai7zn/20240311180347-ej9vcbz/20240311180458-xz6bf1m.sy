{"ID":"20240311180458-xz6bf1m","Spec":"1","Type":"NodeDocument","Properties":{"id":"20240311180458-xz6bf1m","title":"ByteToMessageDecoder","updated":"20240311180527"},"Children":[{"ID":"20240311180506-ey7o1kc","Type":"NodeParagraph","Properties":{"id":"20240311180506-ey7o1kc","updated":"20240311180506"},"Children":[{"Type":"NodeText","Data":"Netty 提供 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"ByteToMessageDecoder"},{"Type":"NodeText","Data":"​ 类用于处理流数据。该类是 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"ChannelInboundHandler"},{"Type":"NodeText","Data":"​ 的一个实现，应重写 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"decode"},{"Type":"NodeText","Data":"​ 方法"}]},{"ID":"20240311180506-iflpkso","Type":"NodeList","ListData":{},"Properties":{"id":"20240311180506-iflpkso","updated":"20240311180506"},"Children":[{"ID":"20240311180506-5brrc0j","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20240311180506-5brrc0j","updated":"20240311180506"},"Children":[{"ID":"20240311180506-yerr9ul","Type":"NodeParagraph","Properties":{"id":"20240311180506-yerr9ul","updated":"20240311180506"},"Children":[{"Type":"NodeText","Data":"自动累计接收的 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"ByteBuf"},{"Type":"NodeText","Data":"​ 数据流，第二个参数 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"in"},{"Type":"NodeText","Data":"​ 即累积的数据流"}]}]},{"ID":"20240311180506-hku676p","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20240311180506-hku676p","updated":"20240311180506"},"Children":[{"ID":"20240311180506-na8zmnr","Type":"NodeParagraph","Properties":{"id":"20240311180506-na8zmnr","updated":"20240311180506"},"Children":[{"Type":"NodeText","Data":"每当判断数据流可以组成一个完整的数据，在方法中构造出对应数据并加入第三个参数 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"out"},{"Type":"NodeText","Data":"​ 列表中"}]}]}]},{"ID":"20240311180506-sltei82","Type":"NodeParagraph","Properties":{"id":"20240311180506-sltei82","updated":"20240311180506"},"Children":[{"Type":"NodeText","Data":"以下示例中，当接收的数据超过 4 个字节，就读出一个无符号整型数据存入输出列表"}]},{"ID":"20240311180506-c1wd353","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20240311180506-c1wd353","updated":"20240311180506"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"amF2YQ=="},{"Type":"NodeCodeBlockCode","Data":"public class MyByteToMessageDecoder extends ByteToMessageDecoder {\n\n    @Override\n    protected void decode(ChannelHandlerContext ctx, ByteBuf in, List\u003cObject\u003e out) {\n        if (in.readableBytes() \u003e= 4) {\n            out.add(in.readUnsignedInt());\n        }\n    }\n}\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20240311180506-exz7g4h","Type":"NodeParagraph","Properties":{"id":"20240311180506-exz7g4h","updated":"20240311180506"},"Children":[{"Type":"NodeText","Data":"Netty 内置了一系列 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"ByteToMessageDecoder"},{"Type":"NodeText","Data":"​ 实现，用于处理不同数据协议（如 HTTP，SSL 等）、不同数据类型（XML，JSON，Zlib 等）"}]},{"ID":"20240311180520-ms9ujek","Type":"NodeParagraph","Properties":{"id":"20240311180520-ms9ujek","updated":"20240311180520"},"Children":[{"Type":"NodeText","Data":"​"},{"Type":"NodeImage","Data":"span","Children":[{"Type":"NodeBang"},{"Type":"NodeOpenBracket"},{"Type":"NodeLinkText","Data":"Pasted image 20230902144618"},{"Type":"NodeCloseBracket"},{"Type":"NodeOpenParen"},{"Type":"NodeLinkDest","Data":"assets/Pasted image 20230902144618-20240311180520-aukeqch.png"},{"Type":"NodeCloseParen"}]},{"Type":"NodeText","Data":"​"}]},{"ID":"20240311180527-0n6l3w1","Type":"NodeParagraph","Properties":{"id":"20240311180527-0n6l3w1","updated":"20240311180527"},"Children":[{"Type":"NodeText","Data":"经过这类 Decoder 后，通过管道传递到后面的对象就不是 ByteBuf 了，对应 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"channelRead"},{"Type":"NodeText","Data":"​ 的 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"msg"},{"Type":"NodeText","Data":"​ 对象就是对应上个 Decoder 输出的类型了。"}]}]}