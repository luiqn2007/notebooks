{"ID":"20240310164830-ffyo691","Spec":"1","Type":"NodeDocument","Properties":{"id":"20240310164830-ffyo691","title":"condition_variable","updated":"20240310164900"},"Children":[{"ID":"20240310164830-7c3pf8w","Type":"NodeParagraph","Properties":{"id":"20240310164830-7c3pf8w","updated":"20240310164852"},"Children":[{"Type":"NodeText","Data":"​"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"std::condition_variable"},{"Type":"NodeText","Data":"​ 可以实现阻塞一个线程，并在满足某些条件或超时时唤醒线程，需要配合锁实现。以下为一个 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"CountDownLatch"},{"Type":"NodeText","Data":"​ 的一个实现："}]},{"ID":"20240310164900-zkoevh6","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20240310164900-zkoevh6","updated":"20240310164900"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"Yysr"},{"Type":"NodeCodeBlockCode","Data":"#include \u003ciostream\u003e\n#include \u003cthread\u003e\n#include \u003cmutex\u003e\n#include \u003ccondition_variable\u003e\n#include \u003catomic\u003e\n\nusing namespace std;\n\nint main() {\n    atomic_int count {10};\n\n    mutex m;\n    condition_variable cv;\n\n    thread awaiting = thread([\u0026] () {\n        unique_lock\u003cmutex\u003e lock(m);\n        while (count \u003e 0) {\n            // 每 5ms 检查一次\n            cv.wait_for(lock, chrono::milliseconds(5));\n        }\n        cout \u003c\u003c \"Latch opened!\" \u003c\u003c endl;\n    });\n\n    thread count_down = thread([\u0026] () {\n        while (count \u003e 0) {\n            // 每 1s 计数一次\n            this_thread::sleep_for(chrono::seconds(1));\n            count--;\n            cout \u003c\u003c \"Count = \" \u003c\u003c count \u003c\u003c endl;\n        }\n        cout \u003c\u003c \"CountDown finished!\" \u003c\u003c endl;\n    });\n\n    awaiting.join();\n    count_down.join();\n}\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]}]}