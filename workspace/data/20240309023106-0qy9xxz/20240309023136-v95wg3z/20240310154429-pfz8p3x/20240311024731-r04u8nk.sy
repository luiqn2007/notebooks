{"ID":"20240311024731-r04u8nk","Spec":"1","Type":"NodeDocument","Properties":{"icon":"2620-fe0f","id":"20240311024731-r04u8nk","title":"无状态 λ 表达式","updated":"20240311123544"},"Children":[{"ID":"20240311024915-645by37","Type":"NodeParagraph","Properties":{"id":"20240311024915-645by37","updated":"20240311024931"},"Children":[{"Type":"NodeText","Data":"没有任何捕获的 "},{"Type":"NodeTextMark","TextMarkType":"block-ref","TextMarkBlockRefID":"20240310154429-pfz8p3x","TextMarkBlockRefSubtype":"s","TextMarkTextContent":"lambda 表达式"},{"Type":"NodeText","Data":"称为无状态 lambda 表达式。该类表达式可以隐式转换为一个函数指针。"}]},{"ID":"20240311024915-c3v68uz","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20240311024915-c3v68uz","updated":"20240311024915"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"Yysr"},{"Type":"NodeCodeBlockCode","Data":"int (*op)(int, int);\nop = [](int a, int b) { return a + b; };\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20240311024915-bnhywdf","Type":"NodeParagraph","Properties":{"id":"20240311024915-bnhywdf","updated":"20240311024943"},"Children":[{"Type":"NodeText","Data":"在 "},{"Type":"NodeTextMark","TextMarkType":"tag","TextMarkTextContent":"C++20"},{"Type":"NodeText","Data":"​ 后，无状态 lambda 表达式可以被构造 -- 即其对应类型有了一个无参构造、复制构造等。因此可以将其类型传入一些标准库的泛型（尤其是比较大小的泛型）中："}]},{"ID":"20240311024915-imd9uu6","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20240311024915-imd9uu6","updated":"20240311024915"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"Yysr"},{"Type":"NodeCodeBlockCode","Data":"auto greater = [](auto x, auto y) { return x \u003e y; };\nstd::map\u003cstd::string, int, decltype(greater)\u003e a_map;\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]}]}