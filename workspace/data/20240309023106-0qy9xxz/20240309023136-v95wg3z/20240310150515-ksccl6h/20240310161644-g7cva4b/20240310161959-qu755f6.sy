{"ID":"20240310161959-qu755f6","Spec":"1","Type":"NodeDocument","Properties":{"icon":"2328-fe0f","id":"20240310161959-qu755f6","title":"复制构造","updated":"20240310214938"},"Children":[{"ID":"20240310162008-xsy07ak","Type":"NodeParagraph","Properties":{"id":"20240310162008-xsy07ak","updated":"20240310214843"},"Children":[{"Type":"NodeText","Data":"复制构造是另一个 C++ 自动生成的"},{"Type":"NodeTextMark","TextMarkType":"block-ref","TextMarkBlockRefID":"20240310184029-mq32u1b","TextMarkBlockRefSubtype":"s","TextMarkTextContent":"构造函数"},{"Type":"NodeText","Data":"。复制构造实际是一个接受当前类引用的构造函数。只要不创建自己的复制构造，编译器就会创建该类的复制构造，内容是直接复制所有类成员的变量。"}]},{"ID":"20240310162008-xfdkoxh","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20240310162008-xfdkoxh","updated":"20240310162008"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"Yysr"},{"Type":"NodeCodeBlockCode","Data":"class A {\npublic:\n    A(A \u0026other) {\n    // custom copy constructor\n    }\n}\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20240310162008-pybjlfu","Type":"NodeParagraph","Properties":{"id":"20240310162008-pybjlfu","updated":"20240310162008"},"Children":[{"Type":"NodeText","Data":"复制构造触发的场景包括使用赋值运算符将一个同类型变量复制给另一个变量，函数调用的直接传参，函数返回值返回对象等"}]},{"ID":"20240310162008-hmvnub9","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20240310162008-hmvnub9","updated":"20240310162008"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"Yysr"},{"Type":"NodeCodeBlockCode","Data":"#include\u003ciostream\u003e\n#include\u003cstring\u003e\n\nusing namespace std;\n\nclass A {\n    string name;\n    int times;\npublic:\n    A(const char* name) : name{name}, times{0} {\n        cout \u003c\u003c \"Create A \" \u003c\u003c name \u003c\u003c endl;\n    }\n\n    A(const A \u0026another) : name{another.name}, times{another.times + 1} {\n        cout \u003c\u003c \"Copy from \" \u003c\u003c name \u003c\u003c \", copy times \" \u003c\u003c another.times \u003c\u003c \" -\u003e \" \u003c\u003c times \u003c\u003c endl;\n    }\n\n    void print() {\n        cout \u003c\u003c \"A \" \u003c\u003c name \u003c\u003c \"[\" \u003c\u003c times \u003c\u003c \"]\" \u003c\u003c endl;\n    }\n};\n\nA print_a(A a) {\n    a.print();\n    return a;\n}\n\nint main() {\n    // Create A a\n    A a {\"a\"};\n    // Copy from a, copy times 0 -\u003e 1\n    A a2 = a;\n    // Copy from a, copy times 1 -\u003e 2 --\u003e 发生在实参传参过程中\n    // A a[2]\n    // Copy from a, copy times 2 -\u003e 3 --\u003e 发生在函数返回过程中\n    a2 = print_a(a2);\n    // A a[3]\n    a2.print();\n}\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20240310162008-r9cj2wq","Type":"NodeParagraph","Properties":{"id":"20240310162008-r9cj2wq","updated":"20240310214938"},"Children":[{"Type":"NodeText","Data":"默认复制构造只是复制了所有值，但如果一个类包含了"},{"Type":"NodeTextMark","TextMarkType":"block-ref","TextMarkBlockRefID":"20240310011458-lcoh739","TextMarkBlockRefSubtype":"s","TextMarkTextContent":"指针"},{"Type":"NodeText","Data":"，当原类被释放，若其中的指针也被释放，则复制的对象指针指向的地址行为不可预测。这很危险，"},{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"任何涉及到手动分配内存，保存其指针的类，都应重写复制构造函数并在复制构造中使用"},{"Type":"NodeText","Data":" "},{"Type":"NodeTextMark","TextMarkType":"strong code","TextMarkTextContent":"memcpy"},{"Type":"NodeText","Data":"​​ "},{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"等方式深复制其数据"},{"Type":"NodeText","Data":"。"}]},{"ID":"20240310162008-shgpfac","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20240310162008-shgpfac","updated":"20240310162008"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"Yysr"},{"Type":"NodeCodeBlockCode","Data":"class A {\n    int* value;\n\npublic:\n    A() {\n        value = new int[5];\n    }\n  \n    A(const A \u0026another) {\n        value = new int[5];\n        memcpy(value, another.value, 5 * sizeof(int));\n    }\n  \n    ~A() {\n        delete [] value;\n        value = nullptr;\n    }\n};\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20240310162008-esbhl28","Type":"NodeParagraph","Properties":{"id":"20240310162008-esbhl28","updated":"20240310162008"},"Children":[{"Type":"NodeText","Data":"以上类 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"A"},{"Type":"NodeText","Data":"​ 在构造函数中使用 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"new"},{"Type":"NodeText","Data":"​ 动态申请了一个数组，并在析构函数中释放。这里在复制构造中重新申请了一块内存并复制了这组数据。这样在原对象释放后，不影响新对象。"}]}]}