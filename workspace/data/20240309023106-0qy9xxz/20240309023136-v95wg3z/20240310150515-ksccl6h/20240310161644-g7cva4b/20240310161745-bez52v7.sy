{"ID":"20240310161745-bez52v7","Spec":"1","Type":"NodeDocument","Properties":{"icon":"2620-fe0f","id":"20240310161745-bez52v7","title":"隐式调用","updated":"20240311105510"},"Children":[{"ID":"20240310161745-eyn8z4m","Type":"NodeParagraph","Properties":{"id":"20240310161745-eyn8z4m","updated":"20240311105510"},"Children":[{"Type":"NodeText","Data":"如果一个"},{"Type":"NodeTextMark","TextMarkType":"block-ref","TextMarkBlockRefID":"20240310161644-g7cva4b","TextMarkBlockRefSubtype":"s","TextMarkTextContent":"构造函数"},{"Type":"NodeText","Data":"只接受一个参数，且没有 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"explicit"},{"Type":"NodeText","Data":"​​​ 修饰，就可以将构造接受的参数直接赋值给该类型变量，编译器会隐式调用该构造函数创建对象。这是实现类与结构体的"},{"Type":"NodeTextMark","TextMarkType":"block-ref","TextMarkBlockRefID":"20240310160407-v29pzds","TextMarkBlockRefSubtype":"s","TextMarkTextContent":"隐式转换"},{"Type":"NodeText","Data":"方式之一。"}]},{"ID":"20240310161841-yjdaygo","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20240310161841-yjdaygo","updated":"20240310161841"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"Yysr"},{"Type":"NodeCodeBlockCode","Data":"class Box {\npublic:\n    int width;\n    int height;\n  \n    Box(int i): width {i}, height {i} {\n        cout \u003c\u003c \"Create by int \" \u003c\u003c i \u003c\u003c endl;\n    }\n};\n\nint i = 5;\n// Create by int 5\nBox b1 = i;\n// Create by int 10\nBox b2 = 10;\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]}]}