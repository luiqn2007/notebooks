{"ID":"20240310154939-njid957","Spec":"1","Type":"NodeDocument","Properties":{"icon":"2620-fe0f","id":"20240310154939-njid957","title":"虚函数","updated":"20240310215720"},"Children":[{"ID":"20240310154946-2taqly7","Type":"NodeParagraph","Properties":{"id":"20240310154946-2taqly7","updated":"20240310215720"},"Children":[{"Type":"NodeText","Data":"虚函数以 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"virtual"},{"Type":"NodeText","Data":"​​ 声明，表示"},{"Type":"NodeTextMark","TextMarkType":"block-ref","TextMarkBlockRefID":"20240310114414-28d3ogf","TextMarkBlockRefSubtype":"s","TextMarkTextContent":"函数"},{"Type":"NodeText","Data":"在运行时动态链接而非在编译期由编译器决定。这样要经过一次查表，速度慢一点，但允许"},{"Type":"NodeTextMark","TextMarkType":"block-ref","TextMarkBlockRefID":"20240310154913-up88hl0","TextMarkBlockRefSubtype":"s","TextMarkTextContent":"派生类"},{"Type":"NodeText","Data":"实现自己的代码覆盖基类相同方法。注意有无"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"const"},{"Type":"NodeText","Data":"​​修饰的函数是不同函数。"}]},{"ID":"20240310154946-bslx186","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20240310154946-bslx186","updated":"20240310154946"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"Yysr"},{"Type":"NodeCodeBlockCode","Data":"#include\u003ciostream\u003e\n\nusing namespace std;\n\nclass A {\npublic:\n    virtual void fun1() { cout \u003c\u003c \"A\" \u003c\u003c endl; }\n    void fun2() { cout \u003c\u003c \"A\" \u003c\u003c endl; }\n};\n\nclass B: public A {\npublic:\n    virtual void fun1() override { cout \u003c\u003c \"B\" \u003c\u003c endl; }\n    void fun2() { cout \u003c\u003c \"B\" \u003c\u003c endl; }\n};\n\nint main() {\n    A a;\n    a.fun1(); // A\n    a.fun2(); // A\n\n    B b;\n    b.fun1(); // B\n    b.fun2(); // B\n\n    A *pb = \u0026b;\n    pb-\u003efun1(); // B\n    pb-\u003efun2(); // A\n}\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20240310154946-sm55r31","Type":"NodeParagraph","Properties":{"id":"20240310154946-sm55r31","updated":"20240310154946"},"Children":[{"Type":"NodeText","Data":"当使用 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"A*"},{"Type":"NodeText","Data":"​ 表示 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"b"},{"Type":"NodeText","Data":"​ 对象时，"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"fun1"},{"Type":"NodeText","Data":"​ 由于是虚函数，会在运行时查找调用的函数，为 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"B"},{"Type":"NodeText","Data":"​ 类重写的方法；而 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"fun2"},{"Type":"NodeText","Data":"​ 非虚，故在编译期确定了 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"A"},{"Type":"NodeText","Data":"​ 类的 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"fun2"},{"Type":"NodeText","Data":"​ 函数。"}]},{"ID":"20240310154946-iwcsw8j","Type":"NodeParagraph","Properties":{"id":"20240310154946-iwcsw8j","updated":"20240310154946"},"Children":[{"Type":"NodeText","Data":"子类重写基类虚函数时，可使用 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"override"},{"Type":"NodeText","Data":"​ 关键字声明。这个关键字不是必须的，但可以验证基类是否真有该函数避免错误。"}]},{"ID":"20240310154946-79gonnj","Type":"NodeParagraph","Properties":{"id":"20240310154946-79gonnj","updated":"20240310154946"},"Children":[{"Type":"NodeText","Data":"​"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"final"},{"Type":"NodeText","Data":"​ 关键字修饰的虚函数表示该虚函数不允许被类的子类继续重写该函数。"}]}]}