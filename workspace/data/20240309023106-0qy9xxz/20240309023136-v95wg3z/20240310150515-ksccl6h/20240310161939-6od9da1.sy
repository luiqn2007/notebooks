{"ID":"20240310161939-6od9da1","Spec":"1","Type":"NodeDocument","Properties":{"icon":"2620-fe0f","id":"20240310161939-6od9da1","title":"析构函数","updated":"20240311105332"},"Children":[{"ID":"20240310162420-m12ys5p","Type":"NodeParagraph","Properties":{"id":"20240310162420-m12ys5p","updated":"20240311105332"},"Children":[{"Type":"NodeTextMark","TextMarkType":"block-ref","TextMarkBlockRefID":"20240310150515-ksccl6h","TextMarkBlockRefSubtype":"s","TextMarkTextContent":"类"},{"Type":"NodeText","Data":"析构函数没有参数，函数名为 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"~类名"},{"Type":"NodeText","Data":"​​，在复制构造最后一个例子中 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"~A()"},{"Type":"NodeText","Data":"​​ 函数即析构函数，通常用于释放类维护（申请）的内存。当一个对象释放时调用，通常包括："}]},{"ID":"20240310162420-ry9kk8x","Type":"NodeList","ListData":{},"Properties":{"id":"20240310162420-ry9kk8x","updated":"20240310215141"},"Children":[{"ID":"20240310162420-4c3g3mh","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20240310162420-4c3g3mh","updated":"20240310215141"},"Children":[{"ID":"20240310162420-wmoo2wd","Type":"NodeParagraph","Properties":{"id":"20240310162420-wmoo2wd","updated":"20240310215141"},"Children":[{"Type":"NodeText","Data":"对于 "},{"Type":"NodeTextMark","TextMarkType":"code block-ref","TextMarkBlockRefID":"20240310144356-d4msctj","TextMarkBlockRefSubtype":"s","TextMarkTextContent":"new"},{"Type":"NodeText","Data":"​​ 申请的内存，使用 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"delete"},{"Type":"NodeText","Data":"​​ 释放时"}]}]},{"ID":"20240310162420-qilabvx","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20240310162420-qilabvx","updated":"20240310162420"},"Children":[{"ID":"20240310162420-be8pouz","Type":"NodeParagraph","Properties":{"id":"20240310162420-be8pouz","updated":"20240310162420"},"Children":[{"Type":"NodeText","Data":"普通变量在其生存期结束时（如函数返回时）"}]}]}]},{"ID":"20240310162420-o8pd9gv","Type":"NodeParagraph","Properties":{"id":"20240310162420-o8pd9gv","updated":"20240310215203"},"Children":[{"Type":"NodeText","Data":"若类不存在析构函数，则编译器会默认生成一个非"},{"Type":"NodeTextMark","TextMarkType":"block-ref","TextMarkBlockRefID":"20240310154939-njid957","TextMarkBlockRefSubtype":"s","TextMarkTextContent":"虚函数"},{"Type":"NodeText","Data":"的无任何实现的析构函数。"}]},{"ID":"20240310162508-ino0g3t","Type":"NodeParagraph","Properties":{"id":"20240310162508-ino0g3t","updated":"20240310162559"},"Children":[{"Type":"NodeText","Data":"如果将一个派生类赋值给其基类类型的变量（或指针）时，析构时析构函数的调用规则为："}]},{"ID":"20240310162420-3tgm3qg","Type":"NodeList","ListData":{},"Properties":{"id":"20240310162420-3tgm3qg","updated":"20240310215219"},"Children":[{"ID":"20240310162420-e4yiq1v","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20240310162420-e4yiq1v","updated":"20240310215219"},"Children":[{"ID":"20240310162420-lsevfg0","Type":"NodeParagraph","Properties":{"id":"20240310162420-lsevfg0","updated":"20240310215219"},"Children":[{"Type":"NodeText","Data":"析构函数为虚函数时，总是会调用子类的析构函数"}]}]},{"ID":"20240310162420-j211bbs","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20240310162420-j211bbs","updated":"20240310162420"},"Children":[{"ID":"20240310162420-n0drs5p","Type":"NodeParagraph","Properties":{"id":"20240310162420-n0drs5p","updated":"20240310162420"},"Children":[{"Type":"NodeText","Data":"析构函数为非虚函数时，若值对应的类型是子类，则调用子类构造，否则调用基类构造"}]}]}]},{"ID":"20240310162420-81u2au6","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20240310162420-81u2au6","updated":"20240310162420"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"Yysr"},{"Type":"NodeCodeBlockCode","Data":"using namespace std;\n\nclass A {\npublic:\n    ~A() {\n        cout \u003c\u003c \"~A\" \u003c\u003c endl;\n    }\n};\n\nclass B : public A {\npublic:\n    ~B() {\n        cout \u003c\u003c \"~B\" \u003c\u003c endl;\n    }\n};\n\nint main() {\n    B *b1 = new B{};\n    B *b2 = new B{};\n    A *a1 = b1;\n    // ~A\n    delete a1;\n    // ~B\n    // ~A\n    delete b2;\n}\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20240310162420-teiwa1e","Type":"NodeParagraph","Properties":{"id":"20240310162420-teiwa1e","updated":"20240310215228"},"Children":[{"Type":"NodeText","Data":"因此，一个类若重写了析构函数，且该类可能派生子类，则必须将该类的析构函数声明成虚函数"}]}]}