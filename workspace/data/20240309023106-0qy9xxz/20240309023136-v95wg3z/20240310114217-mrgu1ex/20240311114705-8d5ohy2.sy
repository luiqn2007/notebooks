{"ID":"20240311114705-8d5ohy2","Spec":"1","Type":"NodeDocument","Properties":{"icon":"1f527","id":"20240311114705-8d5ohy2","tags":"C++11","title":"noexcept","updated":"20240311115006"},"Children":[{"ID":"20240311114720-amdd20b","Type":"NodeParagraph","Properties":{"id":"20240311114720-amdd20b","updated":"20240311114821"},"Children":[{"Type":"NodeText","Data":"传统的声明方法只能声明函数会抛出"},{"Type":"NodeTextMark","TextMarkType":"block-ref","TextMarkBlockRefID":"20240310114217-mrgu1ex","TextMarkBlockRefSubtype":"s","TextMarkTextContent":"异常"},{"Type":"NodeText","Data":"，但无法声明函数不会抛出异常。"}]},{"ID":"20240311114720-kacah9g","Type":"NodeParagraph","Properties":{"id":"20240311114720-kacah9g","updated":"20240311114834"},"Children":[{"Type":"NodeText","Data":"确定一个函数是否抛出异常是有意义的，尤其是在"},{"Type":"NodeTextMark","TextMarkType":"block-ref","TextMarkBlockRefID":"20240310162017-6jmflci","TextMarkBlockRefSubtype":"s","TextMarkTextContent":"移动构造"},{"Type":"NodeText","Data":"中。当一个对象使用移动构造时，可能数据移动到一部分后产生异常，此时中断操作会造成数据丢失。（语义上数据已经移动到新对象里了）"}]},{"ID":"20240311114720-eu03qrj","Type":"NodeParagraph","Properties":{"id":"20240311114720-eu03qrj","updated":"20240311115006"},"Children":[{"Type":"NodeText","Data":"​"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"noexcept"},{"Type":"NodeText","Data":"​ 是一个说明符。该声明说明"},{"Type":"NodeTextMark","TextMarkType":"block-ref","TextMarkBlockRefID":"20240310114414-28d3ogf","TextMarkBlockRefSubtype":"s","TextMarkTextContent":"函数"},{"Type":"NodeText","Data":"不可能发生任何异常。这类函数中抛出异常时，不会展开堆栈，而是直接交给 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"std::terminate"},{"Type":"NodeText","Data":"​ 结束程序。使用该关键字的场景通常为："}]},{"ID":"20240311114954-z64ojw2","Type":"NodeList","ListData":{},"Properties":{"id":"20240311114954-z64ojw2","updated":"20240311114954"},"Children":[{"ID":"20240311114954-u6sv05o","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20240311114954-u6sv05o","updated":"20240311114954"},"Children":[{"ID":"20240311114954-ei1agkb","Type":"NodeParagraph","Properties":{"id":"20240311114954-ei1agkb","updated":"20240311114954"},"Children":[{"Type":"NodeText","Data":"一定不会出现异常的函数，通常非常短，复杂度极低"}]}]},{"ID":"20240311114954-abxag18","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20240311114954-abxag18","updated":"20240311114954"},"Children":[{"ID":"20240311114954-djqrhiy","Type":"NodeParagraph","Properties":{"id":"20240311114954-djqrhiy","updated":"20240311114954"},"Children":[{"Type":"NodeText","Data":"目标是一定不会出现异常的函数，该类函数一旦出错，抛出异常不如直接终止程序"}]}]}]},{"ID":"20240311114720-oc31qvp","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20240311114720-oc31qvp","updated":"20240311114720"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"Yysr"},{"Type":"NodeCodeBlockCode","Data":"struct X {\n    int f() noexcept { ... }\n}\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20240311114720-58owo7c","Type":"NodeParagraph","Properties":{"id":"20240311114720-58owo7c","updated":"20240311114720"},"Children":[{"Type":"NodeText","Data":"​"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"noexcept"},{"Type":"NodeText","Data":"​ 也可以通过括号接收一个布尔常量表达式，当结果为 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"true"},{"Type":"NodeText","Data":"​ 时表示函数不可能发生异常，否则可能发生异常，尤其是在模板时很有用。下面函数定义了一个 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"move"},{"Type":"NodeText","Data":"​ 函数，当 T 为一个基础类型时，该函数不可能抛出异常；否则，可能抛出异常。"}]},{"ID":"20240311114720-ipdgyb5","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20240311114720-ipdgyb5","updated":"20240311114720"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"Yysr"},{"Type":"NodeCodeBlockCode","Data":"template\u003ctypename T\u003e\nT move(const T \u0026o) noexcept(std::is_fundamental\u003cT\u003e::value) { ... }\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20240311114720-4r00y34","Type":"NodeParagraph","Properties":{"id":"20240311114720-4r00y34","updated":"20240311114720"},"Children":[{"Type":"NodeText","Data":"由于 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"noexcept"},{"Type":"NodeText","Data":"​ 是在编译时而不是运行时触发，我们可以在括号里进行一个函数调用，内部 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"noexcept"},{"Type":"NodeText","Data":"​ 在被调函数可能抛出异常时返回 true"}]},{"ID":"20240311114720-szp9x14","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20240311114720-szp9x14","updated":"20240311114720"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"Yysr"},{"Type":"NodeCodeBlockCode","Data":"template\u003ctypename T\u003e\nT move(const T \u0026o) noexcept(noexcept(T(o))) { ... }\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20240311114720-vbmn24q","Type":"NodeParagraph","Properties":{"id":"20240311114720-vbmn24q","updated":"20240311114720"},"Children":[{"Type":"NodeText","Data":"上面函数中包含了一个 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"noexcept(noexcept(T(o)))"},{"Type":"NodeText","Data":"​，内层 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"noexcept"},{"Type":"NodeText","Data":"​ 判断 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"T(const T\u0026amp;)"},{"Type":"NodeText","Data":"​ 函数是否可能抛出异常，当 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"T(const \u0026amp;T)"},{"Type":"NodeText","Data":"​ 带有 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"noexcept"},{"Type":"NodeText","Data":"​ 时 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"move"},{"Type":"NodeText","Data":"​ 函数也是 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"noexcept"},{"Type":"NodeText","Data":"​ 的，否则就是可能抛出异常的。"}]},{"ID":"20240311114720-4c5d8g4","Type":"NodeParagraph","Properties":{"id":"20240311114720-4c5d8g4","updated":"20240311114720"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"带有"},{"Type":"NodeText","Data":" "},{"Type":"NodeTextMark","TextMarkType":"strong code","TextMarkTextContent":"noexcept"},{"Type":"NodeText","Data":"​ "},{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"与不带有该标记的函数签名是两个不同的函数签名。"},{"Type":"NodeText","Data":" 因此，我们可以就此设计不同的实现。"}]},{"ID":"20240311114720-lvfe4nc","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20240311114720-lvfe4nc","updated":"20240311114720"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"Yysr"},{"Type":"NodeCodeBlockCode","Data":"// 带有 noexcept 的 swap 实现，用于带有移动构造的对象\ntemplate\u003ctypename T\u003e\nvoid swap_impl(T\u0026 a, T\u0026 b, std::integral_constant\u003cbool, true\u003e) noexcept {\n    T tmp(std::move(a));\n    a = std::move(b);\n    b = std::move(tmp);\n}\n\n// 不带 noexcept 的 swap 实现，用于不带移动构造的对象\ntemplate\u003ctypename T\u003e\nvoid swap_impl(T\u0026 a, T\u0026 b, std::integral_constant\u003cbool, false\u003e) {\n    T tmp(a);\n    a = b;\n    b = tmp;\n}\n\n// 实现函数\ntemplate\u003ctypename T\u003e\nvoid swap(T\u0026 a, T\u0026 b)\nnoexcept(noexcept(swap_impl(a, b, std::integral_const\u003cbool,\n                            noexcept(T(std::move(a)))\n                         \u0026\u0026 noexcept(a.operator=(std::move(b)))\u003e))) {\n    swap_impl(a, b, std::integral_const\u003cbool,\n                            noexcept(T(std::move(a)))\n                         \u0026\u0026 noexcept(a.operator=(std::move(b)))\u003e());\n}\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20240311114720-ro8u986","Type":"NodeParagraph","Properties":{"id":"20240311114720-ro8u986","updated":"20240311114720"},"Children":[{"Type":"NodeText","Data":"上面是一个判断移动构造优化的 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"swap"},{"Type":"NodeText","Data":"​ 实现函数。通过检查对象带有移动构造和移动赋值运算符实现，确定使用哪个函数。"}]}]}