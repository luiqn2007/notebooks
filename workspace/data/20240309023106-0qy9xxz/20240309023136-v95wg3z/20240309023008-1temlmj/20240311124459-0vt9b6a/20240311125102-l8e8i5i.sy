{"ID":"20240311125102-l8e8i5i","Spec":"1","Type":"NodeDocument","Properties":{"icon":"2620-fe0f","id":"20240311125102-l8e8i5i","title":"系统 API 手写局部变量","updated":"20240311125131"},"Children":[{"ID":"20240311125120-gjjaafb","Type":"NodeParagraph","Properties":{"id":"20240311125120-gjjaafb","updated":"20240311125125"},"Children":[{"Type":"NodeText","Data":"Windows：通过 TlsAlloc 分配一个 "},{"Type":"NodeTextMark","TextMarkType":"em","TextMarkTextContent":"线程局部存储槽索引（TLS slot index）"},{"Type":"NodeText","Data":"，实质是 "},{"Type":"NodeTextMark","TextMarkType":"em","TextMarkTextContent":"线程内部环境块（TEB）"},{"Type":"NodeText","Data":" 的线程局部存储数组的索引"}]},{"ID":"20240311125120-95erxum","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20240311125120-95erxum","updated":"20240311125120"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"Yysr"},{"Type":"NodeCodeBlockCode","Data":"#include \u003cwindows.h\u003e\n#include \u003ccstdio\u003e\n\nDWORD tlsThreadName;\n\n// 线程执行的任务方法\nDWORD WINAPI Fun(LPVOID lpParam) {\n    // 初始化线程数据\n    LPVOID lpvData;\n    // 通过 LocalAlloc 申请内存\n    lpvData = LocalAlloc(LPTR, 20 * sizeof(char));\n    sprintf((char*) lpvData, \"Thread %lu\", GetCurrentThreadId());\n    // 保存当前值 -- 实际上 TLS 保存的是一个指针\n    TlsSetValue(tlsThreadName, lpvData);\n\n    for (int i = 0; i \u003c 10; ++i) {\n        // 通过 TlsGetValue 获取值\n        printf(\"Thread %s: %d\\n\", (char*) TlsGetValue(tlsThreadName), i);\n    }\n\n    // 释放通过 LocalAlloc 申请的内存\n    LocalFree(lpvData);\n    return 0L;\n}\n\nint main() {\n    // 通过 TlsAlloc 申请一个空槽位（索引）\n    tlsThreadName = TlsAlloc();\n\n    // 创建两个线程，运行并等待结束\n    HANDLE hThread1 = CreateThread(NULL, 0, Fun, NULL, 0, NULL);\n    HANDLE hThread2 = CreateThread(NULL, 0, Fun, NULL, 0, NULL);\n    WaitForSingleObject(hThread1, INFINITE);\n    WaitForSingleObject(hThread2, INFINITE);\n\n    // 释放占用的索引\n    TlsFree(tlsThreadName);\n    return 0;\n}\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20240311125120-cbbhvv6","Type":"NodeParagraph","Properties":{"id":"20240311125120-cbbhvv6","updated":"20240311125129"},"Children":[{"Type":"NodeText","Data":"Linux：通过 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"pthread_key_create"},{"Type":"NodeText","Data":"​ 与 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"pthread_key_delete"},{"Type":"NodeText","Data":"​ 创建与释放线程存储对象"}]},{"ID":"20240311125120-u425dyu","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20240311125120-u425dyu","updated":"20240311125120"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"Yysr"},{"Type":"NodeCodeBlockCode","Data":"#include \u003cpthread.h\u003e\n#include \u003ccstdio\u003e\n\npthread_key_t key;\n\n// 线程执行的任务方法\nvoid *fun(void *p) {\n    // 初始化线程变量\n    char name[21];\n    pthread_t thread = *static_cast\u003cpthread_t *\u003e(p);\n    pthread_getname_np(thread, name, (size_t) 20);\n    pthread_setspecific(key, name);\n\n    for (int i = 0; i \u003c 10; ++i) {\n        // 通过 TlsGetValue 获取值\n        printf(\"Thread %s: %d\\n\", (char *) pthread_getspecific(key), i);\n    }\n  \n    return nullptr;\n}\n\nint main() {\n    // 申请一个键\n    pthread_key_create(\u0026key, nullptr);\n    // 创建两个线程，执行方法\n    pthread_t ps0, ps1;\n    pthread_create(\u0026ps0, nullptr, fun, \u0026ps0);\n    pthread_create(\u0026ps1, nullptr, fun, \u0026ps1);\n    pthread_join(ps0, nullptr);\n    pthread_join(ps1, nullptr);\n    // 移除键\n    pthread_key_delete(key);\n    return 0;\n}\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20240311125120-86nsbwb","Type":"NodeParagraph","Properties":{"id":"20240311125120-86nsbwb","updated":"20240311125131"},"Children":[{"Type":"NodeText","Data":"编译器方法：gcc 使用 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"__thread"},{"Type":"NodeText","Data":"​ 修饰变量，vs 使用 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"__declspec(thread)"},{"Type":"NodeText","Data":"​ 修饰变量"}]},{"ID":"20240311125120-s67fusj","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20240311125120-s67fusj","updated":"20240311125120"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"Yysr"},{"Type":"NodeCodeBlockCode","Data":"#include \u003cwindows.h\u003e\n#include \u003ccstdio\u003e\n\n// 根据编译器选择修饰\n#ifdef __GNUC__                       // gcc\n__thread char name[20];\n#elif _MSC_VER                        // vs\n__declspec(thread) char name[20];\n#endif\n\n// 线程执行的任务方法\nDWORD WINAPI Fun(LPVOID lpParam) {\n    sprintf(name, \"Thread %lu\", GetCurrentThreadId());\n    for (int i = 0; i \u003c 10; ++i) {\n        // 通过 TlsGetValue 获取值\n        printf(\"Thread %s: %d\\n\", name, i);\n    }\n    return 0L;\n}\n\nint main() {\n    // 创建两个线程，运行并等待结束\n    HANDLE hThread1 = CreateThread(NULL, 0, Fun, NULL, 0, NULL);\n    HANDLE hThread2 = CreateThread(NULL, 0, Fun, NULL, 0, NULL);\n    WaitForSingleObject(hThread1, INFINITE);\n    WaitForSingleObject(hThread2, INFINITE);\n    return 0;\n}\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]}]}