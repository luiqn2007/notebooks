{"ID":"20240311120405-kxkms79","Spec":"1","Type":"NodeDocument","Properties":{"icon":"2620-fe0f","id":"20240311120405-kxkms79","tags":"C++20","title":"自动生成比较运算符","updated":"20240311120514"},"Children":[{"ID":"20240311120455-pznhevq","Type":"NodeParagraph","Properties":{"id":"20240311120455-pznhevq","updated":"20240311120455"},"Children":[{"Type":"NodeText","Data":"早期，C++ "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"std::rel_ops"},{"Type":"NodeText","Data":"​ 头文件允许根据 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"=="},{"Type":"NodeText","Data":"​，"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"\u0026lt;"},{"Type":"NodeText","Data":"​ 两个运算符生成其他自定义运算符。"}]},{"ID":"20240311120455-71zgtfr","Type":"NodeParagraph","Properties":{"id":"20240311120455-71zgtfr","updated":"20240311120514"},"Children":[{"Type":"NodeText","Data":"C++20 之后，只要实现了 "},{"Type":"NodeTextMark","TextMarkType":"code block-ref","TextMarkBlockRefID":"20240310014343-nwovoef","TextMarkBlockRefSubtype":"s","TextMarkTextContent":"\u0026lt;=\u0026gt;"},{"Type":"NodeText","Data":"​ 运算符，编译器将自动生成对应的 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"\u0026lt;"},{"Type":"NodeText","Data":"​，"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"\u0026gt;"},{"Type":"NodeText","Data":"​，"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"\u0026lt;="},{"Type":"NodeText","Data":"​，"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"\u0026gt;="},{"Type":"NodeText","Data":"​ 四种运算符。"}]},{"ID":"20240311120455-a1u5zj5","Type":"NodeParagraph","Properties":{"id":"20240311120455-a1u5zj5","updated":"20240311120455"},"Children":[{"Type":"NodeTextMark","TextMarkType":"em","TextMarkTextContent":"注意：由于性能问题，"},{"Type":"NodeTextMark","TextMarkType":"em code","TextMarkTextContent":"=="},{"Type":"NodeText","Data":"​ "},{"Type":"NodeTextMark","TextMarkType":"em","TextMarkTextContent":"运算符并没有从"},{"Type":"NodeText","Data":" "},{"Type":"NodeTextMark","TextMarkType":"em code","TextMarkTextContent":"\u0026lt;=\u0026gt;"},{"Type":"NodeText","Data":"​ "},{"Type":"NodeTextMark","TextMarkType":"em","TextMarkTextContent":"中派生。但定义了"},{"Type":"NodeText","Data":" "},{"Type":"NodeTextMark","TextMarkType":"em code","TextMarkTextContent":"=="},{"Type":"NodeText","Data":"​ "},{"Type":"NodeTextMark","TextMarkType":"em","TextMarkTextContent":"运算符的对象可以直接生成"},{"Type":"NodeText","Data":" "},{"Type":"NodeTextMark","TextMarkType":"em code","TextMarkTextContent":"!="},{"Type":"NodeText","Data":"​ "},{"Type":"NodeTextMark","TextMarkType":"em","TextMarkTextContent":"运算符"}]},{"ID":"20240311120455-vuw2u2w","Type":"NodeParagraph","Properties":{"id":"20240311120455-vuw2u2w","updated":"20240311120455"},"Children":[{"Type":"NodeText","Data":"在实现了 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"\u0026lt;"},{"Type":"NodeText","Data":"​，"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"=="},{"Type":"NodeText","Data":"​ 运算符后，可以手动声明实现默认的 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"\u0026lt;=\u0026gt;"},{"Type":"NodeText","Data":"​ 运算符"}]},{"ID":"20240311120455-azxqs2m","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20240311120455-azxqs2m","updated":"20240311120455"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"Yysr"},{"Type":"NodeCodeBlockCode","Data":"struct Data {\n    bool operator==(const Data \u0026rhs) const { ... }\n    bool operator\u003c(const Data \u0026rhs) const { ... }\n};\n\nstruct ThreeWay {\n    Data m;\n    // 调用了 Data 的对应函数\n    std::strong_ordering operator\u003c=\u003e(const ThreeWay \u0026rhs) const = default;\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]}]}