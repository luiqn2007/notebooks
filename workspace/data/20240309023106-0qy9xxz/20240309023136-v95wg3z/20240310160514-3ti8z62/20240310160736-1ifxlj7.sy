{"ID":"20240310160736-1ifxlj7","Spec":"1","Type":"NodeDocument","Properties":{"icon":"2620-fe0f","id":"20240310160736-1ifxlj7","title":"函数模板","updated":"20240310222301"},"Children":[{"ID":"20240310160743-wcamagq","Type":"NodeParagraph","Properties":{"id":"20240310160743-wcamagq","updated":"20240310221920"},"Children":[{"Type":"NodeTextMark","TextMarkType":"block-ref","TextMarkBlockRefID":"20240310114414-28d3ogf","TextMarkBlockRefSubtype":"s","TextMarkTextContent":"函数"},{"Type":"NodeTextMark","TextMarkType":"block-ref","TextMarkBlockRefID":"20240310160514-3ti8z62","TextMarkBlockRefSubtype":"s","TextMarkTextContent":"模板"},{"Type":"NodeText","Data":"是用于生成一组函数的代码。"}]},{"ID":"20240310160743-dugxmtn","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20240310160743-dugxmtn","updated":"20240310160743"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"Yysr"},{"Type":"NodeCodeBlockCode","Data":"template\u003cclass T\u003e\nT max(const T values[], size_t length);\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20240310160743-1ex6ryl","Type":"NodeParagraph","Properties":{"id":"20240310160743-1ex6ryl","updated":"20240310160743"},"Children":[{"Type":"NodeText","Data":"当使用不同类型调用该函数（模板）时，编译器会自动生成其对应的代码。"}]},{"ID":"20240310160743-4mc4elf","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20240310160743-4mc4elf","updated":"20240310160743"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"Yysr"},{"Type":"NodeCodeBlockCode","Data":"template\u003ctypename T, size_t length\u003e\nT* new_array() {\n    return new T[length];\n}\n\nint main() {\n    int *array_int = new_array\u003cint, 5\u003e();\n    long *array_long = new_array\u003clong, 3\u003e();\n\n    delete [] array_int;\n    delete [] array_long;\n}\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20240310160743-zspwqok","Type":"NodeParagraph","Properties":{"id":"20240310160743-zspwqok","updated":"20240310160743"},"Children":[{"Type":"NodeText","Data":"上面那段代码等效于"}]},{"ID":"20240310160743-6u1zxx6","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20240310160743-6u1zxx6","updated":"20240310160743"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"Yysr"},{"Type":"NodeCodeBlockCode","Data":"int* new_array_int() {\n    return new int[5];\n}\n\nlong* new_array_long() {\n    return new long[3];\n}\n\nint main() {\n    int *array_int = new_array_int();\n    long *array_long = new_array_long();\n\n    delete [] array_int;\n    delete [] array_long;\n}\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20240310160743-fkjijw8","Type":"NodeParagraph","Properties":{"id":"20240310160743-fkjijw8","updated":"20240310160743"},"Children":[{"Type":"NodeText","Data":"当然生成的函数究竟叫什么 这个看编译器，但原理就是编译器在编译时，将函数模板"},{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"实例化"},{"Type":"NodeText","Data":"成实际的函数。详见[[Cpp 模板#On-Demand 实例化]]"}]},{"ID":"20240310160743-zc7yzcg","Type":"NodeParagraph","Properties":{"id":"20240310160743-zc7yzcg","updated":"20240310160743"},"Children":[{"Type":"NodeText","Data":"当使用只带有模板类型的方法时，若编译器可以推断出每个类型的具体值，则不需要手动指定模板类型，这个过程称为实参演绎"}]},{"ID":"20240310160753-i5chx2m","Type":"NodeParagraph","Properties":{"id":"20240310160753-i5chx2m","style":"color: var(--b3-card-info-color);background-color: var(--b3-card-info-background);","updated":"20240310160812"},"Children":[{"Type":"NodeText","Data":"实参演绎：当使用模板类型参数，且没有手动指定时，编译器可以根据参数类型确定对应模板类型的实际类型"}]},{"ID":"20240310160822-le0sfx8","Type":"NodeParagraph","Properties":{"id":"20240310160822-le0sfx8","style":"color: var(--b3-card-warning-color);background-color: var(--b3-card-warning-background);","updated":"20240310160825"},"Children":[{"Type":"NodeText","Data":"注意实参演绎中不允许自动类型转换，且当以引用形式使用（T\u0026）时字符串不会演绎成 "},{"Type":"NodeTextMark","Properties":{"parent-style":"color: var(--b3-card-warning-color);background-color: var(--b3-card-warning-background);"},"TextMarkType":"code","TextMarkTextContent":"char*"},{"Type":"NodeKramdownSpanIAL","Data":"{: parent-style=\"color: var(--b3-card-warning-color);background-color: var(--b3-card-warning-background);\"}"},{"Type":"NodeText","Data":"​，而是带有具体长度的字符数组"}]},{"ID":"20240310160827-3vya3o6","Type":"NodeParagraph","Properties":{"id":"20240310160827-3vya3o6","updated":"20240310160835"},"Children":[{"Type":"NodeText","Data":"当同时存在普通函数和模板函数可匹配调用时，编译器会选择普通函数而非模板函数。"}]},{"ID":"20240310160844-h3ni7af","Type":"NodeBlockquote","Properties":{"id":"20240310160844-h3ni7af","updated":"20240310160844"},"Children":[{"Type":"NodeBlockquoteMarker","Data":"\u003e"},{"ID":"20240310160844-5dws4mp","Type":"NodeParagraph","Properties":{"id":"20240310160844-5dws4mp","updated":"20240310160844"},"Children":[{"Type":"NodeText","Data":"使用字符串作为模板类型，且模板类型使用引用时可能会出问题，如："}]},{"ID":"20240310160844-icfdqxx","Type":"NodeParagraph","Properties":{"id":"20240310160844-icfdqxx","updated":"20240310160844"},"Children":[{"Type":"NodeText","Data":"​"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"template\u0026lt;typename T\u0026gt;"},{"Type":"NodeText","Data":"​\n​"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"void print(const T \u0026amp;v1, const T \u0026amp;v2) { ... }"},{"Type":"NodeText","Data":"​"}]},{"ID":"20240310160844-ark5crb","Type":"NodeParagraph","Properties":{"id":"20240310160844-ark5crb","updated":"20240310160844"},"Children":[{"Type":"NodeText","Data":"以 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"print(\u0026quot;Hello\u0026quot;, \u0026quot;World!\u0026quot;);"},{"Type":"NodeText","Data":"​ 方式调用会有异常，此时 T 被识别为 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"char[5]"},{"Type":"NodeText","Data":"​，而 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"\u0026quot;World!\u0026quot;"},{"Type":"NodeText","Data":"​ 识别为 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"char[6]"},{"Type":"NodeText","Data":"​ 类型。此时可以将模板方法声明为"}]},{"ID":"20240310160844-7j6k52o","Type":"NodeParagraph","Properties":{"id":"20240310160844-7j6k52o","updated":"20240310160844"},"Children":[{"Type":"NodeText","Data":"​"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"template\u0026lt;typename T\u0026gt;"},{"Type":"NodeText","Data":"​\n​"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"void print(const T v1, const T v2)"},{"Type":"NodeText","Data":"​"}]},{"ID":"20240310160844-6nimwis","Type":"NodeParagraph","Properties":{"id":"20240310160844-6nimwis","updated":"20240310160844"},"Children":[{"Type":"NodeText","Data":"则可以正常使用，T 被识别为 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"char*"},{"Type":"NodeText","Data":"​，此时发生了实参演绎"}]}]},{"ID":"20240310160845-nz6377f","Type":"NodeParagraph","Properties":{"id":"20240310160845-nz6377f","updated":"20240310160928"},"Children":[{"Type":"NodeText","Data":"当同时存在类型参数和非类型参数时，为了利用实参演绎自动识别类型，可以将类型参数放在所有参数之后"}]},{"ID":"20240310160929-xos33ti","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20240310160929-xos33ti","updated":"20240310160940"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"Yysr"},{"Type":"NodeCodeBlockCode","Data":"template\u003cint count, typename T\u003e\nvoid fill(T arr[count]) {\n    for (int i = 0; i \u003c count; ++i) {\n        arr[i] = T();\n    }\n}\n\nint main() {\n    int arr[10];\n    // 相当于 fill\u003c10, int\u003e\n    fill\u003c10\u003e(arr);\n    return 0;\n}\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20240310160941-jlw1yfj","Type":"NodeParagraph","Properties":{"id":"20240310160941-jlw1yfj"}}]}