{"ID":"20240311225741-thtxhvh","Spec":"1","Type":"NodeDocument","Properties":{"icon":"2620-fe0f","id":"20240311225741-thtxhvh","tags":"C++20","title":"λ 初始化捕获包展开","updated":"20240311225918"},"Children":[{"ID":"20240311225808-i0qvrwp","Type":"NodeParagraph","Properties":{"id":"20240311225808-i0qvrwp","updated":"20240311225830"},"Children":[{"Type":"NodeText","Data":"在之前的 "},{"Type":"NodeTextMark","TextMarkType":"code block-ref","TextMarkBlockRefID":"20240311224157-cwguxlf","TextMarkBlockRefSubtype":"s","TextMarkTextContent":"delay_invoke"},{"Type":"NodeText","Data":"​ 实例中，如果参数过大会产生过多的额外消耗（因为这里是复制构造）。如果是使用引用传递，又依赖于外部的函数环境，因此使用初始化捕获+移动语义是一个比较合理的解决方案："}]},{"ID":"20240311225808-di4su11","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20240311225808-di4su11","updated":"20240311225808"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"Yysr"},{"Type":"NodeCodeBlockCode","Data":"template\u003cclass F, class ...Args\u003e\nauto delay_invoke(F f, Args ...args) {\n    using namespace std;\n    return [f = move(f), tup = make_tuple(move(args)...)]() -\u003e decltype(auto) {\n        return apply(f, tup);\n    };\n}\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20240311225808-2vht5z7","Type":"NodeParagraph","Properties":{"id":"20240311225808-2vht5z7","updated":"20240311225918"},"Children":[{"Type":"NodeText","Data":"这样使用 tuple 进行打包，但一旦复杂起来（例如固定被调函数 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"f"},{"Type":"NodeText","Data":"​，此时需要在 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"apply"},{"Type":"NodeText","Data":"​ 第一个参数传入一个 "},{"Type":"NodeTextMark","TextMarkType":"code block-ref","TextMarkBlockRefID":"20240310154429-pfz8p3x","TextMarkBlockRefSubtype":"s","TextMarkTextContent":"lambda"},{"Type":"NodeText","Data":"​ 表达式中使用引用）难以理解"}]},{"ID":"20240311225808-ynxjeti","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20240311225808-ynxjeti","updated":"20240311225808"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"Yysr"},{"Type":"NodeCodeBlockCode","Data":"template\u003cclass ...Args\u003e\nauto foo(Args ...args) {\n    return (args + ... + 0);\n}\n\ntemplate\u003cclass ...Args\u003e\nauto delay_invoke(Args ...args) {\n    return [tup = std::make_tuple(std::move(args)...)]() -\u003e decltype(auto) {\n        return std::apply([](auto\u0026 ...args) -\u003e decltype(auto) { return foo(args...); } , tup);\n    };\n}\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20240311225808-3r1ujh6","Type":"NodeParagraph","Properties":{"id":"20240311225808-3r1ujh6","updated":"20240311225910"},"Children":[{"Type":"NodeText","Data":"C++20 开始允许"},{"Type":"NodeTextMark","TextMarkType":"block-ref","TextMarkBlockRefID":"20240311224140-t6r6pay","TextMarkBlockRefSubtype":"s","TextMarkTextContent":"形参包展开"},{"Type":"NodeText","Data":"的初始化捕获。但与普通包展开的形式有所不同的是，"},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"..."},{"Type":"NodeText","Data":"​ 在模式之前"}]},{"ID":"20240311225808-8ub4jrx","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20240311225808-8ub4jrx","updated":"20240311225808"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"Yysr"},{"Type":"NodeCodeBlockCode","Data":"template\u003cclass ...Args\u003e\nauto foo(Args ...args) {\n    return (args + ... + 0);\n}\n\ntemplate\u003cclass ...Args\u003e\nauto delay_invoke(Args ...args) {\n    return [...args = std::move(args)]() -\u003e decltype(auto) {\n        return foo(args...);\n    };\n}\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]}]}