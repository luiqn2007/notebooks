{"ID":"20240311025503-ez1fsaa","Spec":"1","Type":"NodeDocument","Properties":{"icon":"2620-fe0f","id":"20240311025503-ez1fsaa","tags":"C++11","title":"返回值优化","updated":"20240311025706"},"Children":[{"ID":"20240311025514-ezja5wv","Type":"NodeParagraph","Properties":{"id":"20240311025514-ezja5wv","style":"color: var(--b3-card-info-color);background-color: var(--b3-card-info-background);","updated":"20240311025519"},"Children":[{"Type":"NodeText","Data":"RVO：Return Value Optimization，返回值操作数为临时对象时的优化"}]},{"ID":"20240311025524-5xi0ij5","Type":"NodeParagraph","Properties":{"id":"20240311025524-5xi0ij5","style":"color: var(--b3-card-info-color);background-color: var(--b3-card-info-background);","updated":"20240311025530"},"Children":[{"Type":"NodeText","Data":"NRVO：NRVO：Named Return Value Optimization：返回值操作数为具名对象时的优化"}]},{"ID":"20240311025537-kgakts4","Type":"NodeParagraph","Properties":{"id":"20240311025537-kgakts4","updated":"20240311025635"},"Children":[{"Type":"NodeText","Data":"C++11 复制消除：在"},{"Type":"NodeTextMark","TextMarkType":"block-ref","TextMarkBlockRefID":"20240310114414-28d3ogf","TextMarkBlockRefSubtype":"s","TextMarkTextContent":"函数"},{"Type":"NodeText","Data":"返回一个对象时，且返回的对象在编译期可确定，不再需要调用"},{"Type":"NodeTextMark","TextMarkType":"block-ref","TextMarkBlockRefID":"20240310161959-qu755f6","TextMarkBlockRefSubtype":"s","TextMarkTextContent":"复制构造"},{"Type":"NodeText","Data":"，可以直接转移到目标位置。该优化策略即 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"RVO"},{"Type":"NodeText","Data":"​ 和 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"NRVO"},{"Type":"NodeText","Data":"​ 优化。"}]},{"ID":"20240311025537-jzcsjmf","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20240311025537-jzcsjmf","updated":"20240311025537"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"Yysr"},{"Type":"NodeCodeBlockCode","Data":"struct X {\npublic:\n    X() { cout \u003c\u003c \"X ctor\\n\"; }\n    X(const X \u0026x) { cout \u003c\u003c \"X copy ctor\\n\"; }\n    ~X() { cout \u003c\u003c \"X dtor\\n\"; }\n};\n\nX make_x_rvo() {\n    return {};\n}\n\nX make_x_nrvo() {\n    X x;\n    return x;\n}\n\nint main() {\n    cout \u003c\u003c \"-------------------------------------\\n\";\n    // X ctor\n    X x1 = make_x_rvo();\n    cout \u003c\u003c \"-------------------------------------\\n\";\n    // X ctor\n    X x2 = make_x_nrvo();\n    cout \u003c\u003c \"-------------------------------------\\n\";\n    return 0;\n    // X dtor\n    // X dtor\n}\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20240311025537-pitwnma","Type":"NodeParagraph","Properties":{"id":"20240311025537-pitwnma","updated":"20240311025537"},"Children":[{"Type":"NodeText","Data":"但如果编译器无法在编译时确定被构造对象是哪一个，则优化会失效："}]},{"ID":"20240311025537-17bdzkl","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20240311025537-17bdzkl","updated":"20240311025537"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"Yysr"},{"Type":"NodeCodeBlockCode","Data":"struct X {\npublic:\n    X() { cout \u003c\u003c \"X ctor\\n\"; }\n    X(const X \u0026x) { cout \u003c\u003c \"X copy ctor\\n\"; }\n    ~X() { cout \u003c\u003c \"X dtor\\n\"; }\n};\n\nX make_x() {\n    X x1, x2;\n    // 编译器无法确定返回的是 x1 还是 x2\n    if (time(nullptr) % 50) {\n        return x1;\n    } else {\n        return x2;\n    }\n}\n\nint main() {\n    cout \u003c\u003c \"-------------------------------------\\n\";\n    // X ctor\n    // X ctor\n    // X copy ctor  --\u003e 从此处开始，返回值优化失效\n    // X dtor\n    // X dtor\n    X x = make_x();\n    cout \u003c\u003c \"-------------------------------------\\n\";\n    return 0;\n    // X dtor\n}\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20240311025602-0snzrtw","Type":"NodeBlockquote","Properties":{"id":"20240311025602-0snzrtw","updated":"20240311025607"},"Children":[{"Type":"NodeBlockquoteMarker","Data":"\u003e"},{"ID":"20240311025602-3q2b9oa","Type":"NodeParagraph","Properties":{"id":"20240311025602-3q2b9oa","updated":"20240311025607"},"Children":[{"Type":"NodeText","Data":"上面的例子中，事实上复制消除还是消除了一次复制构造的调用的，即将 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"make_x()"},{"Type":"NodeText","Data":"​ 的返回值复制到 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"main"},{"Type":"NodeText","Data":"​ 中的 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"x"},{"Type":"NodeText","Data":"​ 对象上"}]}]},{"ID":"20240311025537-mjc9btg","Type":"NodeList","ListData":{},"Properties":{"id":"20240311025537-mjc9btg","updated":"20240311025537"},"Children":[{"ID":"20240311025537-4uhqdme","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20240311025537-4uhqdme","updated":"20240311025537"},"Children":[{"ID":"20240311025537-6acl0rr","Type":"NodeParagraph","Properties":{"id":"20240311025537-6acl0rr","updated":"20240311025537"},"Children":[{"Type":"NodeText","Data":"复制构造必须是可访问的，否则造成语法错误"}]}]},{"ID":"20240311025537-mdngaul","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20240311025537-mdngaul","updated":"20240311025537"},"Children":[{"ID":"20240311025537-q2o2jlo","Type":"NodeParagraph","Properties":{"id":"20240311025537-q2o2jlo","updated":"20240311025537"},"Children":[{"Type":"NodeText","Data":"GCC 禁用复制消除："},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"-fno-elide-constructors"},{"Type":"NodeText","Data":"​"}]}]}]},{"ID":"20240311025537-s1rm7t8","Type":"NodeParagraph","Properties":{"id":"20240311025537-s1rm7t8","updated":"20240311025646"},"Children":[{"Type":"NodeText","Data":"​"},{"Type":"NodeTextMark","TextMarkType":"tag","TextMarkTextContent":"C++14"},{"Type":"NodeText","Data":"​ 要求对于常量表达式和常量初始化而言，编译器应保证 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"RVO"},{"Type":"NodeText","Data":"​，禁止 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"NRVO"},{"Type":"NodeText","Data":"​"}]},{"ID":"20240311025537-99peuy3","Type":"NodeParagraph","Properties":{"id":"20240311025537-99peuy3","updated":"20240311025706"},"Children":[{"Type":"NodeText","Data":"​"},{"Type":"NodeTextMark","TextMarkType":"tag","TextMarkTextContent":"C++17"},{"Type":"NodeText","Data":"​ 规定，在传递临时对象或从函数返回对象时，编译器应忽略对象的复制构造和"},{"Type":"NodeTextMark","TextMarkType":"block-ref","TextMarkBlockRefID":"20240310162017-6jmflci","TextMarkBlockRefSubtype":"s","TextMarkTextContent":"移动构造"},{"Type":"NodeText","Data":"。"}]},{"ID":"20240311025537-w70ka5r","Type":"NodeList","ListData":{},"Properties":{"id":"20240311025537-w70ka5r","updated":"20240311025537"},"Children":[{"ID":"20240311025537-waiu1mi","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20240311025537-waiu1mi","updated":"20240311025537"},"Children":[{"ID":"20240311025537-7u5cdu8","Type":"NodeParagraph","Properties":{"id":"20240311025537-7u5cdu8","updated":"20240311025537"},"Children":[{"Type":"NodeText","Data":"复制和移动构造在这两种情况下永远不会调用和检查，因此可以不存在或不可访问"}]}]},{"ID":"20240311025537-dz3byrd","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20240311025537-dz3byrd","updated":"20240311025537"},"Children":[{"ID":"20240311025537-psz7rlo","Type":"NodeParagraph","Properties":{"id":"20240311025537-psz7rlo","updated":"20240311025537"},"Children":[{"Type":"NodeText","Data":"复制和移动构造中若还有其他副作用，也不会调用"}]}]},{"ID":"20240311025537-jewa5d1","Type":"NodeListItem","ListData":{"BulletChar":42,"Marker":"Kg=="},"Properties":{"id":"20240311025537-jewa5d1","updated":"20240311025537"},"Children":[{"ID":"20240311025537-d4m60cb","Type":"NodeParagraph","Properties":{"id":"20240311025537-d4m60cb","updated":"20240311025537"},"Children":[{"Type":"NodeText","Data":"最终效果是将对象直接构造到目标的存储变量上，避免临时对象的产生\n该规定允许所有类型都可以使用工厂函数。"}]}]}]}]}