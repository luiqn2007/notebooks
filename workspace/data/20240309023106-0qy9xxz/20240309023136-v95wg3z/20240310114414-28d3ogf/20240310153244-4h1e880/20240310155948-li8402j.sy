{"ID":"20240310155948-li8402j","Spec":"1","Type":"NodeDocument","Properties":{"icon":"1f527","id":"20240310155948-li8402j","title":"尾置返回值","updated":"20240310223722"},"Children":[{"ID":"20240310155954-n9moowz","Type":"NodeParagraph","Properties":{"id":"20240310155954-n9moowz","updated":"20240310221542"},"Children":[{"Type":"NodeText","Data":"对于函数，"},{"Type":"NodeTextMark","TextMarkType":"code block-ref","TextMarkBlockRefID":"20240310155505-od3u1cu","TextMarkBlockRefSubtype":"s","TextMarkTextContent":"auto"},{"Type":"NodeText","Data":"​​ 用于尾置返回值类型的占位"}]},{"ID":"20240310155954-5y0hg6y","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20240310155954-5y0hg6y","updated":"20240310155954"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"Yysr"},{"Type":"NodeCodeBlockCode","Data":"auto func(int a, int b) -\u003e int {  \n    return a + b;  \n}\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20240310155954-4ag0p81","Type":"NodeParagraph","Properties":{"id":"20240310155954-4ag0p81","updated":"20240310223722"},"Children":[{"Type":"NodeText","Data":"尾置返回值配合"},{"Type":"NodeTextMark","TextMarkType":"block-ref","TextMarkBlockRefID":"20240310155845-6y4a4zf","TextMarkBlockRefSubtype":"d","TextMarkTextContent":"decltype"},{"Type":"NodeText","Data":"，常用于"},{"Type":"NodeTextMark","TextMarkType":"block-ref","TextMarkBlockRefID":"20240310160514-3ti8z62","TextMarkBlockRefSubtype":"s","TextMarkTextContent":"模板"},{"Type":"NodeText","Data":"中推断返回值类型。"}]},{"ID":"20240310223453-s812hhf","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20240310223453-s812hhf","updated":"20240310223453"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"Yysr"},{"Type":"NodeCodeBlockCode","Data":"template\u003ctypename T\u003e\n?? add(T \u0026a, T \u0026b) {\n    decltype(a+b) result = a + b;\n    return result;\n}\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20240310223453-yzynvz1","Type":"NodeParagraph","Properties":{"id":"20240310223453-yzynvz1","updated":"20240310223508"},"Children":[{"Type":"NodeText","Data":"C++ 编译器扫描源码时，其顺序是自左向右扫描。因此在指定函数类型时，编译器还无法获得其形参列表，我们要让函数的返回值往后放一放，至少让编译器知道形参列表再说，此时使用自动推断类型 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"auto"},{"Type":"NodeText","Data":"​ 关键字"}]},{"ID":"20240310223453-0bvma9l","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20240310223453-0bvma9l","updated":"20240310223453"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"Yysr"},{"Type":"NodeCodeBlockCode","Data":"template\u003ctypename T\u003e\nauto add(T \u0026a, T \u0026b) -\u003e decltype(a + b) {\n    return a + b;\n}\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20240310223453-h5v60ie","Type":"NodeParagraph","Properties":{"id":"20240310223453-h5v60ie","updated":"20240310223453"},"Children":[{"Type":"NodeText","Data":"以上，一个用于泛型的尾置返回值函数就完成了。"}]},{"ID":"20240310223453-46drzyj","Type":"NodeParagraph","Properties":{"id":"20240310223453-46drzyj","updated":"20240310223453"},"Children":[{"Type":"NodeText","Data":"事实上，编译器不会去确切的求 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"a+b"},{"Type":"NodeText","Data":"​ 的值是多少，它可以根据 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"a"},{"Type":"NodeText","Data":"​ 和 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"b"},{"Type":"NodeText","Data":"​ 的类型，去查找对应的运算符。因此，我们还能这么用："}]},{"ID":"20240310223453-573bzdg","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20240310223453-573bzdg","updated":"20240310223453"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"Yysr"},{"Type":"NodeCodeBlockCode","Data":"template\u003ctypename T\u003e\nauto add(vector\u003cT\u003e \u0026a, vector\u003cT\u003e \u0026b) -\u003e decltype(vector[0] + vector[1]) {\n    return vector[0] + vector[1];\n}\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20240310223453-1kglzut","Type":"NodeParagraph","Properties":{"id":"20240310223453-1kglzut","updated":"20240310223453"},"Children":[{"Type":"NodeText","Data":"上面用到了一个泛型容器 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"vector\u0026lt;T\u0026gt;"},{"Type":"NodeText","Data":"​，这和数组差不多。由于不知道 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"vector\u0026lt;T\u0026gt;"},{"Type":"NodeText","Data":"​ 长度，也就是说他可能没有数据存储在内，直接相加可能出异常，但在 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"decltype"},{"Type":"NodeText","Data":"​ 中不需要考虑这些东西，编译器只会去查找 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"vector\u0026lt;T\u0026gt;"},{"Type":"NodeText","Data":"​ 的 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"[]"},{"Type":"NodeText","Data":"​ 运算符，获取他的返回值类型后再查找 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"T"},{"Type":"NodeText","Data":"​ 的 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"+"},{"Type":"NodeText","Data":"​ 运算符，使用他的返回值类型。"}]},{"ID":"20240310223453-52gmcsa","Type":"NodeParagraph","Properties":{"id":"20240310223453-52gmcsa","updated":"20240310223453"}}]}